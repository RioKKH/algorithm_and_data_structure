# アルゴリズムとデータ構造

## 第5章 設計技法 (3) 動的計画法

### 5.1 動的計画法とは

与えられた問題ゼンタいを一連の部分問題に上手に分解し、各部分問題に対する解をメモ化しながら、地位さな部分問題からより大きな部分問題へと順に解を求めて行く手法

### 5.2 動的計画法の例題

==Frog問題==

$N$個の足場があって、$i(0, 1, \cdots, N-1)$番目の足場の高さは$h_i$で与えられる。最初の0番目の足場にカエルがいて、以下のいずれかの行動を繰り返して$N-1$番目の足場を目指す。

- 足場$i$から足場$i+1$へと移動する(コストは$\left|h_i - h_{i+1}\right|$)
- 足場$i$から足場$i+2$へと移動する(コストは$\left|h_i - h_{i+2}\right|$)

カエルが$N-1$番目の足場にたどりつくまでに要するコストの総和の最小値を求める

==問題をグラフの問題として捉え直す==

頂点0から頂点6までの辺をたどっていく方法のうち、たどった各辺の重みの総和の最小値を求める

code5_1.cpp参照

「頂点$i$に至る最小コストを求める」という大きな問題を

- 頂点$i - 1$に至る最小コストを求める(頂点$i-1$から$i$へ移動する場合)

- 頂点$i - 2$に至る最小コストを求める(頂点$i-2$から$i$へ移動する場合)

という2つの小さな部分問題に分解した。

小さな部分問題についても最適性が要請されるという構造を、**部分構造最適性** (optimal substructure)と呼ぶ。このような構造を利用して各部分問題に対する最適値を順に決定していく手法を**動的計画法** (dynamic programming, DP)と呼ぶ。

### 5.3 動的計画法に関連する諸概念

#### 5.3.1 緩和

- 緩和(relaxation)
  詳細は14章で説明する。

- 緩和処理を実現するための関数`chmin`

  ```cpp
  template<class T> void chmin(T& a, T b) { // (注意)aが参照
      if (a > b) {
          a = b;
      }
  }
  ```

  一般に、グラフ上で頂点$u$から頂点$v$へと遷移する辺があって、その遷移コストを$c$とした時に
  $$
  \text{chmin}(\text{dp[v]}, \text{dp[u]}+c)
  $$
  とする処理を、その辺に関する**緩和** (relaxation)という。計算量は$O(N)$となる。

  緩和を意識してFrog問題を実装する。

  code5_3.cpp参照

#### 5.3.2 貰う遷移形式と配る遷移形式

- 貰う遷移形式(pull-based)
  $\text{dp}[i-2]$や$\text{dp}[i-1]$の値が確定しているときに$\text{dp}[i]$の値を更新する考え方

- 配る遷移形式(push-based)
  $\text{dp}[i]$の値が確定しているときに、その値を用いて$\text{dp}[i+1]$や$\text{dp}[i+2]$の値を更新する考え方

- 配る遷移方式を用いて動的計画法を実装した場合

  code5_4.cppを参照

  計算量は貰う遷移形式でも配る遷移形式でも$O(N)$となる

#### 5.3.3 貰う遷移形式と配る遷移形式の比較

==緩和処理の順序のポイント==

頂点$u$から頂点$v$へと遷移する辺に関する緩和処理を成立させる為には、$\text{dp}[u]$の値が確定していることが必要

#### 5.3.4 全探索のメモ化としての動的計画法

動的計画法はしばしば、単純な全探索アルゴリズムを設計すると指数時間となるような問題に対しても、多項式時間アルゴリズムを導けるような強力な道具となっている。

再帰関数を用いて実装した場合

```cpp
// rec(i) : 足場0から足場iにいたるまでの最小コスト
long long rec(int i) {
    // 足場0のコストは0
    if (i == 0) {
        return 0;
    }
    // 答えを格納する変数を INF に初期化する
    long long res = INF;
    
    // 頂点i - 1から来た場合
    chmin(res, rec(i - 1) + abs(h[i]- h[i - 1]));
    
    // 頂点i - 2から来た場合
    if (i > 1) {
        chmin(res, rec(i - 2) + abs(h[i] - h[i - 2]));
    }
    
    // 答えを返す
    return res;
}
```

==再帰関数のメモ化==

`rec(1)`が一度呼び出されてその答えが分かったのならば、その時点で答えをメモ化しておく。このようにメモ化を施した再帰のことを**メモ化再帰**と呼ぶことがある。計算量は$O(N)$となる。

code5_6.cpp参照

### 5.3 動的計画法の例(1) ：ナップサック問題

==ナップサック問題==

$N$個の品物が有り, $i(=0, 1, \cdots, N-1)$番目の品物の重さは$\text{weight}_i$, 価値は$\text{value}_i$で与えられる。

この$N$個のしなものから、重さの総和が$W$をこえないように、いくつか選ぶ。選んだ品物の価値の総和として考えられる最大値を求める

==動的計画法の部分問題の作り方の基本パターン==

$N$個の対象物${0, 1, \cdots, N-1}$に関する問題に対して、最初の$i$この対象物${0, 1, \cdots, i-1}$に関する問題を部分問題として考える

各段階においていくつかの選択肢が存在する${\rightarrow}$動的計画法を適用することを考える。

ナップサック問題では重さも考える必要があるので、部分問題(テーブル)の定義を変更する

==ナップサック問題に対する動的計画法==

$\text{dp}[i][w]{\leftarrow}$最初の$i$個の品物${0, 1, \cdots, i-1}$までのなかから重さが$w$を超えないように選んだときの、価値の総和の最大値

